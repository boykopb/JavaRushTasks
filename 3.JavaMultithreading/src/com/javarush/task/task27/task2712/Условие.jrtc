taskKey="com.javarush.task.task27.task2712.big19"\n\nРесторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!


Требования:
1.	В методе main класса Restaurant должно быть создано 5 планшетов.
2.	В методе main класса Restaurant должно быть создано 2 повара.
3.	Повара должны быть зарегистрированы в множестве поваров в StatisticManager.
4.	Должен быть создан и запущен тред на основе RandomOrderGeneratorTask.
5.	Конструктор класса RandomOrderGeneratorTask должен соответствовать описанному в условии задачи.
6.	Оба повара должны быть добавлены каждому планшету в качестве наблюдателей.


Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet> tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



