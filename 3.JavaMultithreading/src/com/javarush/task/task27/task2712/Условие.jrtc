taskKey="com.javarush.task.task27.task2712.big22"\n\nРесторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.


Требования:
1.	В классе Restaurant должно быть создано private final static поле orderQueue типа LinkedBlockingQueue.
2.	В классе Cook должно быть создано private поле queue типа LinkedBlockingQueue и сеттер.
3.	В классе Tablet должно быть создано private поле queue типа LinkedBlockingQueue.
4.	Класс Tablet не должен быть потомком класса Observable.
5.	Класс Cook должен поддерживать интерфейс Runnable.
6.	Общая логика приготовления заказов и показа рекламы должна быть сохранена.
7.	Класс OrderManager должен быть удален.


Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.



Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.



Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.



Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.



Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.



